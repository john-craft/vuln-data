import { createWriteStream, createReadStream, existsSync, mkdirSync } from 'fs';
import { writeFile, readFile } from 'fs/promises';
import { createGunzip } from 'zlib';
import { pipeline } from 'stream/promises';
import { dirname } from 'path';

// NVD JSON 2.0 Feed URLs
const NVD_FEEDS = {
  2025: 'https://nvd.nist.gov/feeds/json/cve/2.0/nvdcve-2.0-2025.json.gz',
  2024: 'https://nvd.nist.gov/feeds/json/cve/2.0/nvdcve-2.0-2024.json.gz',
  2023: 'https://nvd.nist.gov/feeds/json/cve/2.0/nvdcve-2.0-2023.json.gz'
};

// Project configurations with CPE patterns and description keywords
const TRACKED_PROJECTS = {
  // Web Servers & Reverse Proxies
  nginx: {
    name: 'NGINX',
    cpePatterns: [
      'cpe:2.3:a:f5:nginx_open_source:*'
    ],
    descriptionKeywords: [
      'nginx open source',
      'nginx plus'
    ]
  },
  apache: {
    name: 'Apache HTTP Server',
    cpePatterns: [
      'cpe:2.3:a:apache:http_server:*'
    ],
    descriptionKeywords: [
      'apache http server',
      'apache httpd'
    ]
  },
  tomcat: {
    name: 'Apache Tomcat',
    cpePatterns: [
      'cpe:2.3:a:apache:tomcat:*'
    ],
    descriptionKeywords: [
      'apache tomcat'
    ]
  },

  // JavaScript Runtimes
  nodejs: {
    name: 'Node.js',
    cpePatterns: [
      'cpe:2.3:a:nodejs:node.js:*'
    ],
    descriptionKeywords: [
      'node.js',
      'nodejs'
    ]
  },
  bun: {
    name: 'Bun',
    cpePatterns: [
      'cpe:2.3:a:oven:bun:*'
    ],
    descriptionKeywords: [
      'bun javascript runtime',
      'bun runtime'
    ]
  },
  deno: {
    name: 'Deno',
    cpePatterns: [
      'cpe:2.3:a:deno:deno:*'
    ],
    descriptionKeywords: [
      'deno runtime',
      'deno is a'
    ]
  },

  // Programming Languages
  python3: {
    name: 'Python',
    cpePatterns: [
      'cpe:2.3:a:python:python:*'
    ],
    descriptionKeywords: [
      'python programming language',
      'cpython'
    ]
  },
  php: {
    name: 'PHP',
    cpePatterns: [
      'cpe:2.3:a:php:php:*'
    ],
    descriptionKeywords: [
      'php programming language',
      'php hypertext preprocessor'
    ]
  },
  perl: {
    name: 'Perl',
    cpePatterns: [
      'cpe:2.3:a:perl:perl:*'
    ],
    descriptionKeywords: [
      'perl programming language'
    ]
  },
  golang: {
    name: 'Go',
    cpePatterns: [
      'cpe:2.3:a:golang:go:*'
    ],
    descriptionKeywords: [
      'go programming language',
      'golang'
    ]
  },
  java: {
    name: 'Java',
    cpePatterns: [
      'cpe:2.3:a:oracle:jdk:*',
      'cpe:2.3:a:oracle:openjdk:*'
    ],
    descriptionKeywords: [
      'oracle java',
      'openjdk'
    ]
  },
  dotnet: {
    name: '.NET',
    cpePatterns: [
      'cpe:2.3:a:microsoft:.net:*',
      'cpe:2.3:a:microsoft:.net_core:*'
    ],
    descriptionKeywords: [
      'microsoft .net',
      'dotnet core'
    ]
  },

  // Web Frameworks
  fastapi: {
    name: 'FastAPI',
    cpePatterns: [
      'cpe:2.3:a:tiangolo:fastapi:*'
    ],
    descriptionKeywords: [
      'fastapi framework',
      'fastapi is a'
    ]
  },
  django: {
    name: 'Django',
    cpePatterns: [
      'cpe:2.3:a:djangoproject:django:*'
    ],
    descriptionKeywords: [
      'django framework',
      'django web framework'
    ]
  },
  flask: {
    name: 'Flask',
    cpePatterns: [
      'cpe:2.3:a:palletsprojects:flask:*'
    ],
    descriptionKeywords: [
      'flask framework',
      'flask web framework'
    ]
  },

  // Databases & Caching
  redis: {
    name: 'Redis',
    cpePatterns: [
      'cpe:2.3:a:redis:redis:*'
    ],
    descriptionKeywords: [
      'redis is an open source',
      'redis is a'
    ]
  },
  postgresql: {
    name: 'PostgreSQL',
    cpePatterns: [
      'cpe:2.3:a:postgresql:postgresql:*'
    ],
    descriptionKeywords: [
      'postgresql database'
    ]
  },
  memcached: {
    name: 'Memcached',
    cpePatterns: [
      'cpe:2.3:a:memcached:memcached:*'
    ],
    descriptionKeywords: [
      'memcached caching system'
    ]
  },

  // Message Queues
  rabbitmq: {
    name: 'RabbitMQ',
    cpePatterns: [
      'cpe:2.3:a:rabbitmq:rabbitmq:*',
      'cpe:2.3:a:pivotal:rabbitmq:*'
    ],
    descriptionKeywords: [
      'rabbitmq message broker'
    ]
  },

  // Build Tools
  maven: {
    name: 'Apache Maven',
    cpePatterns: [
      'cpe:2.3:a:apache:maven:*'
    ],
    descriptionKeywords: [
      'apache maven',
      'maven build tool'
    ]
  },
  gradle: {
    name: 'Gradle',
    cpePatterns: [
      'cpe:2.3:a:gradle:gradle:*'
    ],
    descriptionKeywords: [
      'gradle build tool'
    ]
  },

  // System Tools
  busybox: {
    name: 'BusyBox',
    cpePatterns: [
      'cpe:2.3:a:busybox:busybox:*'
    ],
    descriptionKeywords: [
      'busybox utilities'
    ]
  },
  bash: {
    name: 'Bash',
    cpePatterns: [
      'cpe:2.3:a:gnu:bash:*'
    ],
    descriptionKeywords: [
      'bash shell',
      'gnu bash'
    ]
  },
  fluentbit: {
    name: 'Fluent Bit',
    cpePatterns: [
      'cpe:2.3:a:fluentbit:fluent_bit:*'
    ],
    descriptionKeywords: [
      'fluent bit',
      'fluent-bit'
    ]
  },

  // Operating Systems (keeping existing ones)
  debian: {
    name: 'Debian Linux',
    cpePatterns: [
      'cpe:2.3:o:debian:debian_linux:*'
    ]
  },
  alpine: {
    name: 'Alpine Linux',
    cpePatterns: [
      'cpe:2.3:o:alpinelinux:alpine_linux:*'
    ]
  }
};

// Ensure cache directory exists
const CACHE_DIR = './src/data/cache';
if (!existsSync(CACHE_DIR)) {
  mkdirSync(CACHE_DIR, { recursive: true });
}

/**
 * Download and extract a GZ file from NVD, splitting into chunks
 * @param {string} url - NVD feed URL
 * @param {string} baseOutputPath - Base path for chunked files (without extension)
 * @param {number} chunkSize - Maximum number of CVEs per chunk
 */
async function downloadAndExtractToChunks(url, baseOutputPath, chunkSize = 5000) {
  console.log(`Downloading ${url}...`);
  
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`Failed to download ${url}: ${response.statusText}`);
  }
  
  // Ensure output directory exists
  mkdirSync(dirname(baseOutputPath), { recursive: true });
  
  // Create temporary file for full extraction
  const tempPath = `${baseOutputPath}.temp.json`;
  const gzipStream = createGunzip();
  const writeStream = createWriteStream(tempPath);
  
  // Stream download -> gunzip -> write to temp file
  await pipeline(
    response.body,
    gzipStream,
    writeStream
  );
  
  console.log(`Downloaded and extracted to temporary file`);
  
  // Read the full JSON and split into chunks
  const rawData = await readFile(tempPath, 'utf8');
  const feedData = JSON.parse(rawData);
  
  console.log(`Splitting ${feedData.totalResults} CVEs into chunks of ${chunkSize}...`);
  
  const vulnerabilities = feedData.vulnerabilities || [];
  const totalChunks = Math.ceil(vulnerabilities.length / chunkSize);
  
  // Create chunks directory
  const chunksDir = `${baseOutputPath}-chunks`;
  mkdirSync(chunksDir, { recursive: true });
  
  // Write metadata file with original feed info
  const metadata = {
    version: feedData.version,
    dataType: feedData.dataType,
    dataFormat: feedData.dataFormat,
    dataVersion: feedData.dataVersion,
    timestamp: feedData.timestamp,
    totalResults: feedData.totalResults,
    resultsPerPage: feedData.resultsPerPage,
    startIndex: feedData.startIndex,
    totalChunks: totalChunks,
    chunkSize: chunkSize
  };
  
  await writeFile(`${chunksDir}/metadata.json`, JSON.stringify(metadata, null, 2));
  
  // Split vulnerabilities into chunks
  for (let i = 0; i < totalChunks; i++) {
    const startIdx = i * chunkSize;
    const endIdx = Math.min((i + 1) * chunkSize, vulnerabilities.length);
    const chunk = vulnerabilities.slice(startIdx, endIdx);
    
    const chunkData = {
      chunkIndex: i,
      startIndex: startIdx,
      count: chunk.length,
      vulnerabilities: chunk
    };
    
    const chunkFile = `${chunksDir}/chunk-${String(i + 1).padStart(3, '0')}.json`;
    await writeFile(chunkFile, JSON.stringify(chunkData, null, 2));
    
    console.log(`Created chunk ${i + 1}/${totalChunks}: ${chunk.length} CVEs`);
  }
  
  // Clean up temp file
  await readFile(tempPath, 'utf8').then(() => {
    require('fs').unlinkSync(tempPath);
  }).catch(() => {
    // Ignore cleanup errors
  });
  
  console.log(`Created ${totalChunks} chunks in ${chunksDir}`);
  return chunksDir;
}

/**
 * Check if CVE affects any of the tracked projects
 * @param {Object} cve - CVE object from NVD feed
 * @param {Object} projectConfig - Project configuration to check against (defaults to TRACKED_PROJECTS)
 * @returns {Array} - Array of matching project keys
 */
function getAffectedProjects(cve, projectConfig = TRACKED_PROJECTS) {
  const affectedProjects = [];
  const cveStr = JSON.stringify(cve);
  const description = cve.descriptions?.find(d => d.lang === 'en')?.value?.toLowerCase() || '';
  
  // Check each tracked project
  for (const [projectKey, project] of Object.entries(projectConfig)) {
    let found = false;
    
    // First try CPE pattern matching
    if (project.cpePatterns) {
      for (const pattern of project.cpePatterns) {
        const basePattern = pattern.replace(':*', '');
        if (cveStr.includes(basePattern)) {
          affectedProjects.push(projectKey);
          found = true;
          break;
        }
      }
    }
    
    // If no CPE match, try description keywords (for CVEs awaiting analysis)
    if (!found && project.descriptionKeywords) {
      for (const keyword of project.descriptionKeywords) {
        if (description.includes(keyword.toLowerCase())) {
          affectedProjects.push(projectKey);
          found = true;
          break;
        }
      }
    }
  }
  
  return affectedProjects;
}

/**
 * Extract essential CVE data for visualization
 * @param {Object} cve - CVE object from NVD feed
 * @returns {Object} - Simplified CVE data
 */
function extractCveData(cve) {
  const metrics = cve.metrics?.cvssMetricV31?.[0] || cve.metrics?.cvssMetricV30?.[0];
  
  return {
    id: cve.id,
    publishedDate: cve.published,
    publishedYear: new Date(cve.published).getFullYear(),
    lastModifiedDate: cve.lastModified,
    description: cve.descriptions?.find(d => d.lang === 'en')?.value || '',
    severity: {
      score: metrics?.cvssData?.baseScore || 0,
      severity: metrics?.cvssData?.baseSeverity || 'UNKNOWN',
      vector: metrics?.cvssData?.vectorString || ''
    },
    references: cve.references?.map(ref => ({
      url: ref.url,
      source: ref.source,
      tags: ref.tags || []
    })) || [],
    cisaKev: cve.cisaExploitAdd ? true : false
  };
}

/**
 * Read chunked CVE data and reconstruct full dataset
 * @param {string} chunksDir - Directory containing chunked files
 * @returns {Object} - Reconstructed feed data
 */
async function readChunkedFeed(chunksDir) {
  console.log(`Reading chunked feed from: ${chunksDir}`);
  
  // Read metadata
  const metadataPath = `${chunksDir}/metadata.json`;
  if (!existsSync(metadataPath)) {
    throw new Error(`Metadata file not found: ${metadataPath}`);
  }
  
  const metadata = JSON.parse(await readFile(metadataPath, 'utf8'));
  console.log(`Feed contains ${metadata.totalResults} CVEs across ${metadata.totalChunks} chunks`);
  
  // Read all chunks
  const vulnerabilities = [];
  for (let i = 1; i <= metadata.totalChunks; i++) {
    const chunkFile = `${chunksDir}/chunk-${String(i).padStart(3, '0')}.json`;
    if (existsSync(chunkFile)) {
      const chunkData = JSON.parse(await readFile(chunkFile, 'utf8'));
      vulnerabilities.push(...chunkData.vulnerabilities);
      console.log(`Loaded chunk ${i}/${metadata.totalChunks}: ${chunkData.count} CVEs`);
    } else {
      console.warn(`Missing chunk file: ${chunkFile}`);
    }
  }
  
  // Reconstruct feed format
  return {
    ...metadata,
    vulnerabilities
  };
}

/**
 * Process CVE feed and extract project-specific vulnerabilities
 * @param {string} feedPathOrChunksDir - Path to extracted JSON feed file or chunks directory
 * @param {Object} projectConfig - Project configuration to use (defaults to TRACKED_PROJECTS)
 * @returns {Object} - Project-grouped CVE data
 */
async function processCveFeed(feedPathOrChunksDir, projectConfig = TRACKED_PROJECTS) {
  console.log(`Processing CVE feed: ${feedPathOrChunksDir}`);
  
  let feedData;
  
  // Check if it's a chunks directory or single file
  if (existsSync(`${feedPathOrChunksDir}/metadata.json`)) {
    // It's a chunks directory
    feedData = await readChunkedFeed(feedPathOrChunksDir);
  } else {
    // It's a single file (fallback for existing data)
    const rawData = await readFile(feedPathOrChunksDir, 'utf8');
    feedData = JSON.parse(rawData);
  }
  
  console.log(`Feed contains ${feedData.totalResults} CVEs`);
  
  // Group CVEs by affected projects
  const projectCves = {};
  let processedCount = 0;
  
  for (const cve of feedData.vulnerabilities || []) {
    const cveData = cve.cve;
    const affectedProjects = getAffectedProjects(cveData, projectConfig);
    
    if (affectedProjects.length > 0) {
      const extractedCve = extractCveData(cveData);
      
      for (const projectKey of affectedProjects) {
        if (!projectCves[projectKey]) {
          projectCves[projectKey] = [];
        }
        projectCves[projectKey].push(extractedCve);
      }
    }
    
    processedCount++;
    if (processedCount % 1000 === 0) {
      console.log(`Processed ${processedCount}/${feedData.totalResults} CVEs...`);
    }
  }
  
  // Log results
  for (const [project, cves] of Object.entries(projectCves)) {
    console.log(`Found ${cves.length} CVEs for ${projectConfig[project].name}`);
  }
  
  return projectCves;
}

/**
 * Create timeline-friendly data structure for visualization
 * @param {Object} projectCves - Project-grouped CVE data
 * @param {Object} projectConfig - Project configuration to use (defaults to TRACKED_PROJECTS)
 * @returns {Array} - Array of timeline events
 */
function createTimelineData(projectCves, projectConfig = TRACKED_PROJECTS) {
  const timelineEvents = [];
  
  for (const [projectKey, cves] of Object.entries(projectCves)) {
    for (const cve of cves) {
      timelineEvents.push({
        date: cve.publishedDate.split('T')[0], // YYYY-MM-DD format
        project: projectKey,
        projectName: projectConfig[projectKey].name,
        cve: cve.id,
        severity: cve.severity.severity,
        score: cve.severity.score,
        description: cve.description
      });
    }
  }
  
  // Sort by publication date
  return timelineEvents.sort((a, b) => new Date(a.date) - new Date(b.date));
}

/**
 * Main function to download, extract, and process CVE data
 * @param {number} year - Year to process (e.g., 2024)
 * @param {number} chunkSize - Number of CVEs per chunk (default: 5000)
 */
export async function fetchCveData(year = 2024, chunkSize = 5000) {
  const feedUrl = NVD_FEEDS[year];
  if (!feedUrl) {
    throw new Error(`No feed URL configured for year ${year}`);
  }
  
  const baseOutputPath = `${CACHE_DIR}/nvdcve-${year}`;
  const chunksDir = `${baseOutputPath}-chunks`;
  const outputPath = `${CACHE_DIR}/cve-data-${year}.json`;
  const timelinePath = `${CACHE_DIR}/cve-timeline-${year}.json`;
  
  try {
    // Download and extract to chunks if not already present
    if (!existsSync(chunksDir)) {
      await downloadAndExtractToChunks(feedUrl, baseOutputPath, chunkSize);
    } else {
      console.log(`Using cached chunked feed: ${chunksDir}`);
    }
    
    // Process the feed data
    const projectCves = await processCveFeed(chunksDir);
    
    // Create timeline data for visualization
    const timelineData = createTimelineData(projectCves);
    
    // Save processed data
    await writeFile(outputPath, JSON.stringify(projectCves, null, 2));
    await writeFile(timelinePath, JSON.stringify(timelineData, null, 2));
    
    console.log(`Saved processed CVE data to ${outputPath}`);
    console.log(`Saved timeline data to ${timelinePath}`);
    
    return { projectCves, timelineData };
    
  } catch (error) {
    console.error('Error fetching CVE data:', error);
    throw error;
  }
}

/**
 * Filter existing CVE data by a custom project configuration
 * @param {Array} cveData - Existing CVE data array
 * @param {Object} projectConfig - Project configuration to filter by
 * @returns {Object} - Project-grouped CVE data
 */
export function filterCvesByProjects(cveData, projectConfig) {
  const projectCves = {};
  
  for (const cve of cveData) {
    const affectedProjects = getAffectedProjects(cve, projectConfig);
    
    if (affectedProjects.length > 0) {
      const extractedCve = extractCveData(cve);
      
      for (const projectKey of affectedProjects) {
        if (!projectCves[projectKey]) {
          projectCves[projectKey] = [];
        }
        projectCves[projectKey].push(extractedCve);
      }
    }
  }
  
  return projectCves;
}

/**
 * Generate timeline data for custom project configuration
 * @param {Object} projectConfig - Project configuration to analyze
 * @param {Array} years - Years to process (defaults to [2024])
 * @returns {Object} - Timeline data and project CVE counts
 */
export async function generateTimelineForProjects(projectConfig, years = [2024]) {
  console.log(`Generating timeline for ${Object.keys(projectConfig).length} projects across ${years.length} years`);
  
  const allProjectCves = {};
  const allTimelineData = [];
  
  for (const year of years) {
    const chunksDir = `${CACHE_DIR}/nvdcve-${year}-chunks`;
    
    // Check if chunks exist
    if (!existsSync(chunksDir)) {
      console.log(`No cached data found for ${year}, fetching from NVD...`);
      await fetchCveData(year);
    }
    
    // Process the feed data with custom project config
    const yearProjectCves = await processCveFeed(chunksDir, projectConfig);
    
    // Merge results
    for (const [projectKey, cves] of Object.entries(yearProjectCves)) {
      if (!allProjectCves[projectKey]) {
        allProjectCves[projectKey] = [];
      }
      allProjectCves[projectKey].push(...cves);
    }
    
    // Create timeline data for this year
    const yearTimelineData = createTimelineData(yearProjectCves, projectConfig);
    allTimelineData.push(...yearTimelineData);
  }
  
  // Sort combined timeline data
  allTimelineData.sort((a, b) => new Date(a.date) - new Date(b.date));
  
  return {
    projectCves: allProjectCves,
    timelineData: allTimelineData
  };
}

/**
 * Validate a project configuration
 * @param {Object} projectConfig - Project configuration to validate
 * @returns {Object} - Validation results
 */
export function validateProjectConfiguration(projectConfig) {
  const errors = [];
  const warnings = [];
  
  if (!projectConfig || typeof projectConfig !== 'object') {
    return {
      valid: false,
      errors: ['Project configuration must be an object'],
      warnings: []
    };
  }
  
  for (const [projectKey, project] of Object.entries(projectConfig)) {
    // Check required fields
    if (!project.name || typeof project.name !== 'string') {
      errors.push(`Project '${projectKey}' must have a name (string)`);
    }
    
    // Check that at least one matching method is provided
    const hasCpePatterns = project.cpePatterns && Array.isArray(project.cpePatterns) && project.cpePatterns.length > 0;
    const hasKeywords = project.descriptionKeywords && Array.isArray(project.descriptionKeywords) && project.descriptionKeywords.length > 0;
    
    if (!hasCpePatterns && !hasKeywords) {
      errors.push(`Project '${projectKey}' must have either cpePatterns or descriptionKeywords (or both)`);
    }
    
    // Validate CPE patterns
    if (project.cpePatterns) {
      if (!Array.isArray(project.cpePatterns)) {
        errors.push(`Project '${projectKey}' cpePatterns must be an array`);
      } else {
        for (const pattern of project.cpePatterns) {
          if (typeof pattern !== 'string') {
            errors.push(`CPE pattern in '${projectKey}' must be a string: ${pattern}`);
          } else if (!pattern.startsWith('cpe:2.3:')) {
            warnings.push(`CPE pattern in '${projectKey}' should start with 'cpe:2.3:': ${pattern}`);
          }
        }
      }
    }
    
    // Validate description keywords
    if (project.descriptionKeywords) {
      if (!Array.isArray(project.descriptionKeywords)) {
        errors.push(`Project '${projectKey}' descriptionKeywords must be an array`);
      } else {
        for (const keyword of project.descriptionKeywords) {
          if (typeof keyword !== 'string') {
            errors.push(`Description keyword in '${projectKey}' must be a string: ${keyword}`);
          } else if (keyword.length < 3) {
            warnings.push(`Description keyword in '${projectKey}' is very short and may match too broadly: '${keyword}'`);
          }
        }
      }
    }
  }
  
  return {
    valid: errors.length === 0,
    errors,
    warnings
  };
}


// If run directly, fetch 2024 data
if (import.meta.url === `file://${process.argv[1]}`) {
  fetchCveData(2024).catch(console.error);
}